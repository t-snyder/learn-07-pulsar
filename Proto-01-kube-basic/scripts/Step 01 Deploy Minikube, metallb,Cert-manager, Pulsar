#!/bin/bash

# The following scripting is based upon a Pulsar tutorial for running Pulsar in Kubernetes on
# minikube. The url for the tuturial is:
# https://pulsar.apache.org/docs/4.0.x/getting-started-helm/

# Step 1 - Deploys and configures the following:
#            a) minikube, minikube addons (dashboard, metrics-server);
#            b) configures encryption for etcd storage
#            c) creates metallb loadbalancer
#            d) deploys Pulsar and all its components into the Cluster
#            e) Tests access from the Pulsar CLI client
#            f) Allows running of the simple java test program (eclipse, maven) found in the
#               pulsar-client directory within this project.

# This learning prototypes were developed and tested using the following:
#   a) Ubuntu             - 20.04.6 LTS
#   b) Minikube           - 1.34.0
#   c) Kubernetes         - 1.31.0
#   d) Docker             - 27.2.0
#   e) Metallb            - 0.9.6
#   f) Machine config - Processor - Intel® Core™ i7-7700K CPU @ 4.20GHz × 8 
#                       Memory    - 64 GB
#
# Pulsar deployment
# The following deployment was initially generated by running a dry-run from the Pulsar
# minikube Helm chart as follows:
# helm install --dry-run --values ${PROTODIR}/helm/values-minikube.yaml --namespace pulsar pulsar-mini apache/pulsar > kube-pulsar.txt
# From this output the kube deployment components were obtained. This script does a minimal
# installation of only the main required Pulsar components.
#   Component   # Deployed
#    Zookeeper       1
#    Bookie          1
#    Toolset         1
#    Broker          1
#    Proxy           3
# Only the basic elements are deployed - so no PodMonitor, Prometheus, Graphana, PodDisrutpion, etc.
#
#
#################################################################################################
##### Note - Only if it has not already been installed to your dev machine do you need to do this step.
# Install pulsarctl from streamnative - Installs to $HOME/.pulsarctl
sudo bash -c "$(curl -fsSL https://raw.githubusercontent.com/streamnative/pulsarctl/master/install.sh)"
#################################################################################################
            
# Open terminal 1
# Delete prior minikube ( if used and configured prior)
minikube delete

# Start minikube - configure the settings to your requirements and hardware
# Note - normally I use kvm2 as the vm-driver. However istio cni in ambient mode does not
# currently work with kvm2 due to cni incompatibility. The work around is to use the 
# docker vm-driver.
minikube start --cpus 4 --memory 12288 --vm-driver docker --cni kindnet --disk-size 100g

# Addons
minikube addons enable dashboard

# Deploy the addon loadbalancer metallb
minikube addons enable metallb

# Configure loadbalancer ip address range within the same range as the minikube ip
# The configuration is a start ip ( ie. 192.168.49.20 ) and an end ip that makes a 
# range of 10 ip addresses. The range should not overlap the minikube ip
minikube ip
minikube addons configure metallb
  -- Enter Load Balancer Start IP: 
  -- Enter Load Balancer End IP:

# Start dashboard
minikube dashboard

############## Open up a new (2nd) terminal ###################################

# Project Directory
PROTODIR=/media/tim/ExtraDrive1/Projects/learn-07-pulsar/Proto-01-kube-basic

# Create pulsar namespace
kubectl create namespace pulsar

# Generate token keys and a secret for the pulsar cluster
$PROTODIR/scripts-pulsar/generate_token_secret_key.sh -n pulsar -k pulsar-mini

# Generate tokens for the super-users and stores them in secrets
$PROTODIR/scripts-pulsar/generate_token.sh -n pulsar -k pulsar-mini -r proxy-admin
$PROTODIR/scripts-pulsar/generate_token.sh -n pulsar -k pulsar-mini -r broker-admin
$PROTODIR/scripts-pulsar/generate_token.sh -n pulsar -k pulsar-mini -r admin

# Deploy various pulsar component configmaps
kubectl apply -f ${PROTODIR}/kube/pulsar-configmaps.yaml

# No pulsar deployment dependencies
kubectl apply -f ${PROTODIR}/kube/zookeeper-service.yaml
kubectl apply -f ${PROTODIR}/kube/zookeeper-statefulset.yaml
kubectl -n pulsar wait --timeout=10m --for=condition=Ready pod/pulsar-mini-zookeeper-0

# Has no Pulsar deployment dependencies
kubectl apply -f ${PROTODIR}/kube/toolset-service.yaml
kubectl apply -f ${PROTODIR}/kube/toolset-statefulset.yaml

# Create shell into the pulsar-mini-toolset pod and run initialize metadata
kubectl exec -it -n pulsar pulsar-mini-toolset-0 -- /bin/sh
bin/pulsar initialize-cluster-metadata \
    --cluster pulsar-mini \
    --zookeeper pulsar-mini-zookeeper:2181 \
    --configuration-store pulsar-mini-zookeeper:2181 \
    --web-service-url http://pulsar-mini-broker.pulsar.svc.cluster.local:8080/ \
    --web-service-url-tls https://pulsar-mini-broker.pulsar.svc.cluster.local:8443/ \
    --broker-service-url pulsar://pulsar-mini-broker.pulsar.svc.cluster.local:6650/ \
    --broker-service-url-tls pulsar+ssl://pulsar-mini-broker.pulsar.svc.cluster.local:6651

exit

# Requires zookeeper to be up and ready and the pulsar initialize cluster metadata cmd
# to be run
kubectl apply -f ${PROTODIR}/kube/bookie-service.yaml
kubectl apply -f ${PROTODIR}/kube/bookie-statefulset.yaml
kubectl -n pulsar wait --timeout=1m --for=condition=Ready pod/pulsar-mini-bookie-0

# Has Zookeeper and Bookie ready before dependency
kubectl apply -f ${PROTODIR}/kube/broker-service.yaml
kubectl apply -f ${PROTODIR}/kube/broker-statefulset.yaml
kubectl -n pulsar wait --timeout=1m --for=condition=Ready pod/pulsar-mini-broker-0

# Has Zookeeper and Broker ready dependency
kubectl apply -f ${PROTODIR}/kube/proxy-service.yaml
kubectl apply -f ${PROTODIR}/kube/proxy-statefulset.yaml
kubectl -n pulsar wait --timeout=1m --for=condition=Ready pod/pulsar-mini-proxy-0

# To verify exverything is up and running
kubectl get pods -n pulsar
kubectl get services -n pulsar

# Create tenants, namespaces and topics from within the toolset container
kubectl exec -it -n pulsar pulsar-mini-toolset-0 -- /bin/bash

# Create a tenant
bin/pulsar-admin tenants create apache
bin/pulsar-admin tenants list

# Create a namespace
bin/pulsar-admin namespaces create apache/pulsar
bin/pulsar-admin namespaces list apache

# Create a test topic with 4 partitions
bin/pulsar-admin topics create-partitioned-topic apache/pulsar/test-topic -p 4
bin/pulsar-admin topics list-partitioned-topics apache/pulsar

exit

# Set the path for the Pulsar client CLI
export PULSAR_HOME=${PROTODIR}/bin/apache-pulsar-4.0.2

# Determine the exposed proxy url
kubectl get services -n pulsar pulsar-mini-proxy

# Note - the ip address to use is different from the pulsar instructions because we have
# installed the metallb loadbalancer which provides an external ip address for the service.
# So if the output from the above is:
NAME                TYPE           CLUSTER-IP      EXTERNAL-IP     PORT(S)                       AGE
pulsar-mini-proxy   LoadBalancer   10.98.238.247   192.168.49.20   80:30885/TCP,6650:31993/TCP   152m

# The following variables need to be updated in the ${PULSAR_HOME}/conf/client.conf file.Using
# the information output above (Yours will probably be different):
webServerUrl=http://192.168.49.20:80
brokerServerUrl=pulsar://192.168.49.20:6650/
# Save and exit

#Open a different terminal and start a consumer
PROTODIR=/media/tim/ExtraDrive1/Projects/learn-07-pulsar/Proto-01-kube-basic
export PULSAR_HOME=${PROTODIR}/bin/apache-pulsar-4.0.2

${PULSAR_HOME}/bin/pulsar-client consume -s sub apache/pulsar/test-topic  -n 0

#Open a different terminal and start a producer and generate 10 messages
PROTODIR=/media/tim/ExtraDrive1/Projects/learn-07-pulsar/Proto-01-kube-basic
export PULSAR_HOME=${PROTODIR}/bin/apache-pulsar-4.0.2

${PULSAR_HOME}/bin/pulsar-client produce apache/pulsar/test-topic  -m "---------hello apache pulsar-------" -n 10

#You should see a series of the following
# ----- got message -----
# ----------hello apache pulsar--------


# Now test the java pulsar-client project from within eclipse or other ide.
# Steps 
#   1. set the tls static final var to false
#   2. Set up Java Application Run Configuration with the main class 
#      learn.pulsar.PulsarClientMain (Only on initial setup)
#
# Run configuration

# Note - See the main logic. Its very simple.
#   1. Create pulsar client.
#   2. Create consumer (Consumer needs to be created first as it starts processing on the next
#      message produced by the producer after initialization.
#   3. Create producer
#   4. Close all

# This means that when the consumer is closed there will be times it has not processed all
# or the last message. As the purpose of this is to test connectivity it is deemed 
# acceptable.
